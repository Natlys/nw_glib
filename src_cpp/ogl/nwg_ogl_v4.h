#ifndef NWG_OGL_V4_H
#define NWG_OGL_V4_H
#include "nwg_ogl_native.h"

#ifndef GL_VERSION_4_0
#define GL_VERSION_4_0 1
#define GL_SAMPLE_SHADING                 0x8C36
#define GL_MIN_SAMPLE_SHADING_VALUE       0x8C37
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5E
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5F
#define GL_TEXTURE_CUBE_MAP_ARRAY         0x9009
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY 0x900A
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY   0x900B
#define GL_SAMPLER_CUBE_MAP_ARRAY         0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW  0x900D
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY     0x900E
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY 0x900F
// Reuse tokens from ARB_texture_query_lod (none)
// Reuse tokens from ARB_draw_buffers_blend (none)
// Reuse tokens from ARB_draw_indirect
// reuse GL_DRAW_INDIRECT_BUFFER
// reuse GL_DRAW_INDIRECT_BUFFER_BINDING
// Reuse tokens from ARB_gpu_shader5
// reuse GL_GEOMETRY_SHADER_INVOCATIONS
// reuse GL_MAX_GEOMETRY_SHADER_INVOCATIONS
// reuse GL_MIN_FRAGMENT_INTERPOLATION_OFFSET
// reuse GL_MAX_FRAGMENT_INTERPOLATION_OFFSET
// reuse GL_FRAGMENT_INTERPOLATION_OFFSET_BITS
// reuse GL_MAX_VERTEX_STREAMS
// Reuse tokens from ARB_gpu_shader_fp64
// reuse GL_DOUBLE_VEC2
// reuse GL_DOUBLE_VEC3
// reuse GL_DOUBLE_VEC4
// reuse GL_DOUBLE_MAT2
// reuse GL_DOUBLE_MAT3
// reuse GL_DOUBLE_MAT4
// reuse GL_DOUBLE_MAT2x3
// reuse GL_DOUBLE_MAT2x4
// reuse GL_DOUBLE_MAT3x2
// reuse GL_DOUBLE_MAT3x4
// reuse GL_DOUBLE_MAT4x2
// reuse GL_DOUBLE_MAT4x3
// Reuse tokens from ARB_shader_subroutine
// reuse GL_ACTIVE_SUBROUTINES
// reuse GL_ACTIVE_SUBROUTINE_UNIFORMS
// reuse GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS
// reuse GL_ACTIVE_SUBROUTINE_MAX_LENGTH
// reuse GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH
// reuse GL_MAX_SUBROUTINES
// reuse GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS
// reuse GL_NUM_COMPATIBLE_SUBROUTINES
// reuse GL_COMPATIBLE_SUBROUTINES
// Reuse tokens from ARB_tessellation_shader
// reuse GL_PATCHES
// reuse GL_PATCH_VERTICES
// reuse GL_PATCH_DEFAULT_INNER_LEVEL
// reuse GL_PATCH_DEFAULT_OUTER_LEVEL
// reuse GL_TESS_CONTROL_OUTPUT_VERTICES
// reuse GL_TESS_GEN_MODE
// reuse GL_TESS_GEN_SPACING
// reuse GL_TESS_GEN_VERTEX_ORDER
// reuse GL_TESS_GEN_POINT_MODE
// reuse GL_ISOLINES
// reuse GL_FRACTIONAL_ODD
// reuse GL_FRACTIONAL_EVEN
// reuse GL_MAX_PATCH_VERTICES
// reuse GL_MAX_TESS_GEN_LEVEL
// reuse GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS
// reuse GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS
// reuse GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS
// reuse GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS
// reuse GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS
// reuse GL_MAX_TESS_PATCH_COMPONENTS
// reuse GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS
// reuse GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS
// reuse GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS
// reuse GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS
// reuse GL_MAX_TESS_CONTROL_INPUT_COMPONENTS
// reuse GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS
// reuse GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS
// reuse GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS
// reuse GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER
// reuse GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER
// reuse GL_TESS_EVALUATION_SHADER
// reuse GL_TESS_CONTROL_SHADER
// Reuse tokens from ARB_texture_buffer_object_rgb32 (none)
// Reuse tokens from ARB_transform_feedback2
// reuse GL_TRANSFORM_FEEDBACK
// reuse GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED
// reuse GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE
// reuse GL_TRANSFORM_FEEDBACK_BINDING
// Reuse tokens from ARB_transform_feedback3
// reuse GL_MAX_TRANSFORM_FEEDBACK_BUFFERS
// reuse GL_MAX_VERTEX_STREAMS

// OpenGL 4.0 also reuses entry points from these extensions:
// ARB_texture_query_lod (no entry points)
// ARB_draw_indirect
// ARB_gpu_shader5 (no entry points)
// ARB_gpu_shader_fp64
// ARB_shader_subroutine
// ARB_tessellation_shader
// ARB_texture_buffer_object_rgb32 (no entry points)
// ARB_texture_cube_map_array (no entry points)
// ARB_texture_gather (no entry points)
// ARB_transform_feedback2
// ARB_transform_feedback3

#ifdef GLCOREARB_PROTOTYPES
GLAPI void APIENTRY glMinSampleShading(GLfloat value);
GLAPI void APIENTRY glBlendEquationi(GLuint buf, GLenum mode);
GLAPI void APIENTRY glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
GLAPI void APIENTRY glBlendFunci(GLuint buf, GLenum src, GLenum dst);
GLAPI void APIENTRY glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#endif // GLCOREARB_PROTOTYPES
typedef void (APIENTRYP PFNGLMINSAMPLESHADINGPROC) (GLfloat value);
typedef void (APIENTRYP PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (APIENTRYP PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
extern PFNGLMINSAMPLESHADINGPROC OglMinSampleShading;
extern PFNGLBLENDEQUATIONIPROC OglBlendEquationi;
extern PFNGLBLENDEQUATIONSEPARATEIPROC OglBlendEquationSeparatei;
extern PFNGLBLENDFUNCIPROC OglBlendFunci;
extern PFNGLBLENDFUNCSEPARATEIPROC OglBlendFuncSeparatei;
#define glMinSampleShading		OglMinSampleShading
#define glBlendEquationi		OglBlendEquationi
#define glBlendEquationSeparatei		OglBlendEquationSeparatei
#define glBlendFunci		OglBlendFunci
#define glBlendFuncSeparatei		OglBlendFuncSeparatei
#endif	// GL_VERSION_4_0

#ifndef GL_VERSION_4_1
#define GL_VERSION_4_1 1
// Reuse tokens from ARB_ES2_compatibility
// reuse GL_FIXED
// reuse GL_IMPLEMENTATION_COLOR_READ_TYPE
// reuse GL_IMPLEMENTATION_COLOR_READ_FORMAT
// reuse GL_LOW_FLOAT
// reuse GL_MEDIUM_FLOAT
// reuse GL_HIGH_FLOAT
// reuse GL_LOW_INT
// reuse GL_MEDIUM_INT
// reuse GL_HIGH_INT
// reuse GL_SHADER_COMPILER
// reuse GL_SHADER_BINARY_FORMATS
// reuse GL_NUM_SHADER_BINARY_FORMATS
// reuse GL_MAX_VERTEX_UNIFORM_VECTORS
// reuse GL_MAX_VARYING_VECTORS
// reuse GL_MAX_FRAGMENT_UNIFORM_VECTORS
// reuse GL_RGB565
// Reuse tokens from ARB_get_program_binary
// reuse GL_PROGRAM_BINARY_RETRIEVABLE_HINT
// reuse GL_PROGRAM_BINARY_LENGTH
// reuse GL_NUM_PROGRAM_BINARY_FORMATS
// reuse GL_PROGRAM_BINARY_FORMATS
// Reuse tokens from ARB_separate_shader_objects
// reuse GL_VERTEX_SHADER_BIT
// reuse GL_FRAGMENT_SHADER_BIT
// reuse GL_GEOMETRY_SHADER_BIT
// reuse GL_TESS_CONTROL_SHADER_BIT
// reuse GL_TESS_EVALUATION_SHADER_BIT
// reuse GL_ALL_SHADER_BITS
// reuse GL_PROGRAM_SEPARABLE
// reuse GL_ACTIVE_PROGRAM
// reuse GL_PROGRAM_PIPELINE_BINDING
// Reuse tokens from ARB_shader_precision (none)
// Reuse tokens from ARB_vertex_attrib_64bit - all are in GL 3.0 and 4.0 already
// Reuse tokens from ARB_viewport_array - some are in GL 1.1 and ARB_provoking_vertex already
// reuse GL_MAX_VIEWPORTS
// reuse GL_VIEWPORT_SUBPIXEL_BITS
// reuse GL_VIEWPORT_BOUNDS_RANGE
// reuse GL_LAYER_PROVOKING_VERTEX
// reuse GL_VIEWPORT_INDEX_PROVOKING_VERTEX
// reuse GL_UNDEFINED_VERTEX
#endif	// GL_VERSION_4_1

#ifndef GL_VERSION_4_2
#define GL_VERSION_4_2 1
// OpenGL 4.1 reuses entry points from these extensions:
// ARB_ES2_compatibility
// ARB_get_program_binary
// ARB_separate_shader_objects
// ARB_shader_precision (no entry points)
// ARB_vertex_attrib_64bit
// ARB_viewport_array
// OpenGL 4.2 reuses entry points from these extensions:
// ARB_base_instance
// ARB_shading_language_420pack (no entry points)
// ARB_transform_feedback_instanced
// ARB_compressed_texture_pixel_storage (no entry points)
// ARB_conservative_depth (no entry points)
// ARB_internalformat_query
// ARB_map_buffer_alignment (no entry points)
// ARB_shader_atomic_counters
// ARB_shader_image_load_store
// ARB_shading_language_packing (no entry points)
// ARB_texture_storage
// Reuse tokens from ARB_base_instance (none)
// Reuse tokens from ARB_shading_language_420pack (none)
// Reuse tokens from ARB_transform_feedback_instanced (none)
// Reuse tokens from ARB_compressed_texture_pixel_storage
// reuse GL_UNPACK_COMPRESSED_BLOCK_WIDTH
// reuse GL_UNPACK_COMPRESSED_BLOCK_HEIGHT
// reuse GL_UNPACK_COMPRESSED_BLOCK_DEPTH
// reuse GL_UNPACK_COMPRESSED_BLOCK_SIZE
// reuse GL_PACK_COMPRESSED_BLOCK_WIDTH
// reuse GL_PACK_COMPRESSED_BLOCK_HEIGHT
// reuse GL_PACK_COMPRESSED_BLOCK_DEPTH
// reuse GL_PACK_COMPRESSED_BLOCK_SIZE
// Reuse tokens from ARB_conservative_depth (none)
// Reuse tokens from ARB_internalformat_query
// reuse GL_NUM_SAMPLE_COUNTS
// Reuse tokens from ARB_map_buffer_alignment
// reuse GL_MIN_MAP_BUFFER_ALIGNMENT
// Reuse tokens from ARB_shader_atomic_counters
// reuse GL_ATOMIC_COUNTER_BUFFER
// reuse GL_ATOMIC_COUNTER_BUFFER_BINDING
// reuse GL_ATOMIC_COUNTER_BUFFER_START
// reuse GL_ATOMIC_COUNTER_BUFFER_SIZE
// reuse GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE
// reuse GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS
// reuse GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES
// reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER
// reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER
// reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER
// reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER
// reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER
// reuse GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS
// reuse GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS
// reuse GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS
// reuse GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS
// reuse GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS
// reuse GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS
// reuse GL_MAX_VERTEX_ATOMIC_COUNTERS
// reuse GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS
// reuse GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS
// reuse GL_MAX_GEOMETRY_ATOMIC_COUNTERS
// reuse GL_MAX_FRAGMENT_ATOMIC_COUNTERS
// reuse GL_MAX_COMBINED_ATOMIC_COUNTERS
// reuse GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE
// reuse GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS
// reuse GL_ACTIVE_ATOMIC_COUNTER_BUFFERS
// reuse GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX
// reuse GL_UNSIGNED_INT_ATOMIC_COUNTER
// Reuse tokens from ARB_shader_image_load_store
// reuse GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT
// reuse GL_ELEMENT_ARRAY_BARRIER_BIT
// reuse GL_UNIFORM_BARRIER_BIT
// reuse GL_TEXTURE_FETCH_BARRIER_BIT
// reuse GL_SHADER_IMAGE_ACCESS_BARRIER_BIT
// reuse GL_COMMAND_BARRIER_BIT
// reuse GL_PIXEL_BUFFER_BARRIER_BIT
// reuse GL_TEXTURE_UPDATE_BARRIER_BIT
// reuse GL_BUFFER_UPDATE_BARRIER_BIT
// reuse GL_FRAMEBUFFER_BARRIER_BIT
// reuse GL_TRANSFORM_FEEDBACK_BARRIER_BIT
// reuse GL_ATOMIC_COUNTER_BARRIER_BIT
// reuse GL_ALL_BARRIER_BITS
// reuse GL_MAX_IMAGE_UNITS
// reuse GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS
// reuse GL_IMAGE_BINDING_NAME
// reuse GL_IMAGE_BINDING_LEVEL
// reuse GL_IMAGE_BINDING_LAYERED
// reuse GL_IMAGE_BINDING_LAYER
// reuse GL_IMAGE_BINDING_ACCESS
// reuse GL_IMAGE_1D
// reuse GL_IMAGE_2D
// reuse GL_IMAGE_3D
// reuse GL_IMAGE_2D_RECT
// reuse GL_IMAGE_CUBE
// reuse GL_IMAGE_BUFFER
// reuse GL_IMAGE_1D_ARRAY
// reuse GL_IMAGE_2D_ARRAY
// reuse GL_IMAGE_CUBE_MAP_ARRAY
// reuse GL_IMAGE_2D_MULTISAMPLE
// reuse GL_IMAGE_2D_MULTISAMPLE_ARRAY
// reuse GL_INT_IMAGE_1D
// reuse GL_INT_IMAGE_2D
// reuse GL_INT_IMAGE_3D
// reuse GL_INT_IMAGE_2D_RECT
// reuse GL_INT_IMAGE_CUBE
// reuse GL_INT_IMAGE_BUFFER
// reuse GL_INT_IMAGE_1D_ARRAY
// reuse GL_INT_IMAGE_2D_ARRAY
// reuse GL_INT_IMAGE_CUBE_MAP_ARRAY
// reuse GL_INT_IMAGE_2D_MULTISAMPLE
// reuse GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY
// reuse GL_UNSIGNED_INT_IMAGE_1D
// reuse GL_UNSIGNED_INT_IMAGE_2D
// reuse GL_UNSIGNED_INT_IMAGE_3D
// reuse GL_UNSIGNED_INT_IMAGE_2D_RECT
// reuse GL_UNSIGNED_INT_IMAGE_CUBE
// reuse GL_UNSIGNED_INT_IMAGE_BUFFER
// reuse GL_UNSIGNED_INT_IMAGE_1D_ARRAY
// reuse GL_UNSIGNED_INT_IMAGE_2D_ARRAY
// reuse GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY
// reuse GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE
// reuse GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY
// reuse GL_MAX_IMAGE_SAMPLES
// reuse GL_IMAGE_BINDING_FORMAT
// reuse GL_IMAGE_FORMAT_COMPATIBILITY_TYPE
// reuse GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE
// reuse GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS
// reuse GL_MAX_VERTEX_IMAGE_UNIFORMS
// reuse GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS
// reuse GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS
// reuse GL_MAX_GEOMETRY_IMAGE_UNIFORMS
// reuse GL_MAX_FRAGMENT_IMAGE_UNIFORMS
// reuse GL_MAX_COMBINED_IMAGE_UNIFORMS
// Reuse tokens from ARB_shading_language_packing (none)
// Reuse tokens from ARB_texture_storage
// reuse GL_TEXTURE_IMMUTABLE_FORMAT
#endif	// GL_VERSION_4_2

#ifndef GL_VERSION_4_3
#define GL_VERSION_4_3 1
#define GL_NUM_SHADING_LANGUAGE_VERSIONS  0x82E9
#define GL_VERTEX_ATTRIB_ARRAY_LONG       0x874E
// Reuse tokens from ARB_arrays_of_arrays (none, GLSL only)
// Reuse tokens from ARB_fragment_layer_viewport (none, GLSL only)
// Reuse tokens from ARB_shader_image_size (none, GLSL only)
// Reuse tokens from ARB_ES3_compatibility
// reuse GL_COMPRESSED_RGB8_ETC2
// reuse GL_COMPRESSED_SRGB8_ETC2
// reuse GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
// reuse GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
// reuse GL_COMPRESSED_RGBA8_ETC2_EAC
// reuse GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
// reuse GL_COMPRESSED_R11_EAC
// reuse GL_COMPRESSED_SIGNED_R11_EAC
// reuse GL_COMPRESSED_RG11_EAC
// reuse GL_COMPRESSED_SIGNED_RG11_EAC
// reuse GL_PRIMITIVE_RESTART_FIXED_INDEX
// reuse GL_ANY_SAMPLES_PASSED_CONSERVATIVE
// reuse GL_MAX_ELEMENT_INDEX
// Reuse tokens from ARB_clear_buffer_object (none)
// Reuse tokens from ARB_compute_shader
// reuse GL_COMPUTE_SHADER
// reuse GL_MAX_COMPUTE_UNIFORM_BLOCKS
// reuse GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS
// reuse GL_MAX_COMPUTE_IMAGE_UNIFORMS
// reuse GL_MAX_COMPUTE_SHARED_MEMORY_SIZE
// reuse GL_MAX_COMPUTE_UNIFORM_COMPONENTS
// reuse GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS
// reuse GL_MAX_COMPUTE_ATOMIC_COUNTERS
// reuse GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS
// reuse GL_MAX_COMPUTE_LOCAL_INVOCATIONS
// reuse GL_MAX_COMPUTE_WORK_GROUP_COUNT
// reuse GL_MAX_COMPUTE_WORK_GROUP_SIZE
// reuse GL_COMPUTE_LOCAL_WORK_SIZE
// reuse GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER
// reuse GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER
// reuse GL_DISPATCH_INDIRECT_BUFFER
// reuse GL_DISPATCH_INDIRECT_BUFFER_BINDING
// Reuse tokens from ARB_copy_image (none)
// Reuse tokens from KHR_debug
// reuse GL_DEBUG_OUTPUT_SYNCHRONOUS
// reuse GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH
// reuse GL_DEBUG_CALLBACK_FUNCTION
// reuse GL_DEBUG_CALLBACK_USER_PARAM
// reuse GL_DEBUG_SOURCE_API
// reuse GL_DEBUG_SOURCE_WINDOW_SYSTEM
// reuse GL_DEBUG_SOURCE_SHADER_COMPILER
// reuse GL_DEBUG_SOURCE_THIRD_PARTY
// reuse GL_DEBUG_SOURCE_APPLICATION
// reuse GL_DEBUG_SOURCE_OTHER
// reuse GL_DEBUG_TYPE_ERROR
// reuse GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR
// reuse GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR
// reuse GL_DEBUG_TYPE_PORTABILITY
// reuse GL_DEBUG_TYPE_PERFORMANCE
// reuse GL_DEBUG_TYPE_OTHER
// reuse GL_MAX_DEBUG_MESSAGE_LENGTH
// reuse GL_MAX_DEBUG_LOGGED_MESSAGES
// reuse GL_DEBUG_LOGGED_MESSAGES
// reuse GL_DEBUG_SEVERITY_HIGH
// reuse GL_DEBUG_SEVERITY_MEDIUM
// reuse GL_DEBUG_SEVERITY_LOW
// reuse GL_DEBUG_TYPE_MARKER
// reuse GL_DEBUG_TYPE_PUSH_GROUP
// reuse GL_DEBUG_TYPE_POP_GROUP
// reuse GL_DEBUG_SEVERITY_NOTIFICATION
// reuse GL_MAX_DEBUG_GROUP_STACK_DEPTH
// reuse GL_DEBUG_GROUP_STACK_DEPTH
// reuse GL_BUFFER
// reuse GL_SHADER
// reuse GL_PROGRAM
// reuse GL_QUERY
// reuse GL_PROGRAM_PIPELINE
// reuse GL_SAMPLER
// reuse GL_DISPLAY_LIST
// reuse GL_MAX_LABEL_LENGTH
// reuse GL_DEBUG_OUTPUT
// reuse GL_CONTEXT_FLAG_DEBUG_BIT
// reuse GL_STACK_UNDERFLOW
// reuse GL_STACK_OVERFLOW
// Reuse tokens from ARB_explicit_uniform_location
// reuse GL_MAX_UNIFORM_LOCATIONS
// Reuse tokens from ARB_framebuffer_no_attachments
// reuse GL_FRAMEBUFFER_DEFAULT_WIDTH
// reuse GL_FRAMEBUFFER_DEFAULT_HEIGHT
// reuse GL_FRAMEBUFFER_DEFAULT_LAYERS
// reuse GL_FRAMEBUFFER_DEFAULT_SAMPLES
// reuse GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS
// reuse GL_MAX_FRAMEBUFFER_WIDTH
// reuse GL_MAX_FRAMEBUFFER_HEIGHT
// reuse GL_MAX_FRAMEBUFFER_LAYERS
// reuse GL_MAX_FRAMEBUFFER_SAMPLES
// Reuse tokens from ARB_internalformat_query2
// reuse GL_INTERNALFORMAT_SUPPORTED
// reuse GL_INTERNALFORMAT_PREFERRED
// reuse GL_INTERNALFORMAT_RED_SIZE
// reuse GL_INTERNALFORMAT_GREEN_SIZE
// reuse GL_INTERNALFORMAT_BLUE_SIZE
// reuse GL_INTERNALFORMAT_ALPHA_SIZE
// reuse GL_INTERNALFORMAT_DEPTH_SIZE
// reuse GL_INTERNALFORMAT_STENCIL_SIZE
// reuse GL_INTERNALFORMAT_SHARED_SIZE
// reuse GL_INTERNALFORMAT_RED_TYPE
// reuse GL_INTERNALFORMAT_GREEN_TYPE
// reuse GL_INTERNALFORMAT_BLUE_TYPE
// reuse GL_INTERNALFORMAT_ALPHA_TYPE
// reuse GL_INTERNALFORMAT_DEPTH_TYPE
// reuse GL_INTERNALFORMAT_STENCIL_TYPE
// reuse GL_MAX_WIDTH
// reuse GL_MAX_HEIGHT
// reuse GL_MAX_DEPTH
// reuse GL_MAX_LAYERS
// reuse GL_MAX_COMBINED_DIMENSIONS
// reuse GL_COLOR_COMPONENTS
// reuse GL_DEPTH_COMPONENTS
// reuse GL_STENCIL_COMPONENTS
// reuse GL_COLOR_RENDERABLE
// reuse GL_DEPTH_RENDERABLE
// reuse GL_STENCIL_RENDERABLE
// reuse GL_FRAMEBUFFER_RENDERABLE
// reuse GL_FRAMEBUFFER_RENDERABLE_LAYERED
// reuse GL_FRAMEBUFFER_BLEND
// reuse GL_READ_PIXELS
// reuse GL_READ_PIXELS_FORMAT
// reuse GL_READ_PIXELS_TYPE
// reuse GL_TEXTURE_IMAGE_FORMAT
// reuse GL_TEXTURE_IMAGE_TYPE
// reuse GL_GET_TEXTURE_IMAGE_FORMAT
// reuse GL_GET_TEXTURE_IMAGE_TYPE
// reuse GL_MIPMAP
// reuse GL_MANUAL_GENERATE_MIPMAP
// reuse GL_AUTO_GENERATE_MIPMAP
// reuse GL_COLOR_ENCODING
// reuse GL_SRGB_READ
// reuse GL_SRGB_WRITE
// reuse GL_FILTER
// reuse GL_VERTEX_TEXTURE
// reuse GL_TESS_CONTROL_TEXTURE
// reuse GL_TESS_EVALUATION_TEXTURE
// reuse GL_GEOMETRY_TEXTURE
// reuse GL_FRAGMENT_TEXTURE
// reuse GL_COMPUTE_TEXTURE
// reuse GL_TEXTURE_SHADOW
// reuse GL_TEXTURE_GATHER
// reuse GL_TEXTURE_GATHER_SHADOW
// reuse GL_SHADER_IMAGE_LOAD
// reuse GL_SHADER_IMAGE_STORE
// reuse GL_SHADER_IMAGE_ATOMIC
// reuse GL_IMAGE_TEXEL_SIZE
// reuse GL_IMAGE_COMPATIBILITY_CLASS
// reuse GL_IMAGE_PIXEL_FORMAT
// reuse GL_IMAGE_PIXEL_TYPE
// reuse GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST
// reuse GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST
// reuse GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE
// reuse GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE
// reuse GL_TEXTURE_COMPRESSED_BLOCK_WIDTH
// reuse GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT
// reuse GL_TEXTURE_COMPRESSED_BLOCK_SIZE
// reuse GL_CLEAR_BUFFER
// reuse GL_TEXTURE_VIEW
// reuse GL_VIEW_COMPATIBILITY_CLASS
// reuse GL_FULL_SUPPORT
// reuse GL_CAVEAT_SUPPORT
// reuse GL_IMAGE_CLASS_4_X_32
// reuse GL_IMAGE_CLASS_2_X_32
// reuse GL_IMAGE_CLASS_1_X_32
// reuse GL_IMAGE_CLASS_4_X_16
// reuse GL_IMAGE_CLASS_2_X_16
// reuse GL_IMAGE_CLASS_1_X_16
// reuse GL_IMAGE_CLASS_4_X_8
// reuse GL_IMAGE_CLASS_2_X_8
// reuse GL_IMAGE_CLASS_1_X_8
// reuse GL_IMAGE_CLASS_11_11_10
// reuse GL_IMAGE_CLASS_10_10_10_2
// reuse GL_VIEW_CLASS_128_BITS
// reuse GL_VIEW_CLASS_96_BITS
// reuse GL_VIEW_CLASS_64_BITS
// reuse GL_VIEW_CLASS_48_BITS
// reuse GL_VIEW_CLASS_32_BITS
// reuse GL_VIEW_CLASS_24_BITS
// reuse GL_VIEW_CLASS_16_BITS
// reuse GL_VIEW_CLASS_8_BITS
// reuse GL_VIEW_CLASS_S3TC_DXT1_RGB
// reuse GL_VIEW_CLASS_S3TC_DXT1_RGBA
// reuse GL_VIEW_CLASS_S3TC_DXT3_RGBA
// reuse GL_VIEW_CLASS_S3TC_DXT5_RGBA
// reuse GL_VIEW_CLASS_RGTC1_RED
// reuse GL_VIEW_CLASS_RGTC2_RG
// reuse GL_VIEW_CLASS_BPTC_UNORM
// reuse GL_VIEW_CLASS_BPTC_FLOAT
// Reuse tokens from ARB_invalidate_subdata (none)
// Reuse tokens from ARB_multi_draw_indirect (none)
// Reuse tokens from ARB_program_interface_query
// reuse GL_UNIFORM
// reuse GL_UNIFORM_BLOCK
// reuse GL_PROGRAM_INPUT
// reuse GL_PROGRAM_OUTPUT
// reuse GL_BUFFER_VARIABLE
// reuse GL_SHADER_STORAGE_BLOCK
// reuse GL_VERTEX_SUBROUTINE
// reuse GL_TESS_CONTROL_SUBROUTINE
// reuse GL_TESS_EVALUATION_SUBROUTINE
// reuse GL_GEOMETRY_SUBROUTINE
// reuse GL_FRAGMENT_SUBROUTINE
// reuse GL_COMPUTE_SUBROUTINE
// reuse GL_VERTEX_SUBROUTINE_UNIFORM
// reuse GL_TESS_CONTROL_SUBROUTINE_UNIFORM
// reuse GL_TESS_EVALUATION_SUBROUTINE_UNIFORM
// reuse GL_GEOMETRY_SUBROUTINE_UNIFORM
// reuse GL_FRAGMENT_SUBROUTINE_UNIFORM
// reuse GL_COMPUTE_SUBROUTINE_UNIFORM
// reuse GL_TRANSFORM_FEEDBACK_VARYING
// reuse GL_ACTIVE_RESOURCES
// reuse GL_MAX_NAME_LENGTH
// reuse GL_MAX_NUM_ACTIVE_VARIABLES
// reuse GL_MAX_NUM_COMPATIBLE_SUBROUTINES
// reuse GL_NAME_LENGTH
// reuse GL_TYPE
// reuse GL_ARRAY_SIZE
// reuse GL_OFFSET
// reuse GL_BLOCK_INDEX
// reuse GL_ARRAY_STRIDE
// reuse GL_MATRIX_STRIDE
// reuse GL_IS_ROW_MAJOR
// reuse GL_ATOMIC_COUNTER_BUFFER_INDEX
// reuse GL_BUFFER_BINDING
// reuse GL_BUFFER_DATA_SIZE
// reuse GL_NUM_ACTIVE_VARIABLES
// reuse GL_ACTIVE_VARIABLES
// reuse GL_REFERENCED_BY_VERTEX_SHADER
// reuse GL_REFERENCED_BY_TESS_CONTROL_SHADER
// reuse GL_REFERENCED_BY_TESS_EVALUATION_SHADER
// reuse GL_REFERENCED_BY_GEOMETRY_SHADER
// reuse GL_REFERENCED_BY_FRAGMENT_SHADER
// reuse GL_REFERENCED_BY_COMPUTE_SHADER
// reuse GL_TOP_LEVEL_ARRAY_SIZE
// reuse GL_TOP_LEVEL_ARRAY_STRIDE
// reuse GL_LOCATION
// reuse GL_LOCATION_INDEX
// reuse GL_IS_PER_PATCH
// Reuse tokens from ARB_robust_buffer_access_behavior (none)
// Reuse tokens from ARB_shader_storage_buffer_object
// reuse GL_SHADER_STORAGE_BUFFER
// reuse GL_SHADER_STORAGE_BUFFER_BINDING
// reuse GL_SHADER_STORAGE_BUFFER_START
// reuse GL_SHADER_STORAGE_BUFFER_SIZE
// reuse GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS
// reuse GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS
// reuse GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS
// reuse GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS
// reuse GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS
// reuse GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS
// reuse GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS
// reuse GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS
// reuse GL_MAX_SHADER_STORAGE_BLOCK_SIZE
// reuse GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT
// reuse GL_SHADER_STORAGE_BARRIER_BIT
// reuse GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES
// Reuse tokens from ARB_stencil_texturing
// reuse GL_DEPTH_STENCIL_TEXTURE_MODE
// Reuse tokens from ARB_texture_buffer_range
// reuse GL_TEXTURE_BUFFER_OFFSET
// reuse GL_TEXTURE_BUFFER_SIZE
// reuse GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT
// Reuse tokens from ARB_texture_query_levels (none)
// Reuse tokens from ARB_texture_storage_multisample (none)
// Reuse tokens from ARB_texture_view
// reuse GL_TEXTURE_VIEW_MIN_LEVEL
// reuse GL_TEXTURE_VIEW_NUM_LEVELS
// reuse GL_TEXTURE_VIEW_MIN_LAYER
// reuse GL_TEXTURE_VIEW_NUM_LAYERS
// reuse GL_TEXTURE_IMMUTABLE_LEVELS
// Reuse tokens from ARB_vertex_attrib_binding
// reuse GL_VERTEX_ATTRIB_BINDING
// reuse GL_VERTEX_ATTRIB_RELATIVE_OFFSET
// reuse GL_VERTEX_BINDING_DIVISOR
// reuse GL_VERTEX_BINDING_OFFSET
// reuse GL_VERTEX_BINDING_STRIDE
// reuse GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET
// reuse GL_MAX_VERTEX_ATTRIB_BINDINGS

// OpenGL 4.3 reuses entry points from these extensions:
// ARB_arrays_of_arrays (no entry points, GLSL only)
// ARB_fragment_layer_viewport (no entry points, GLSL only)
// ARB_shader_image_size (no entry points, GLSL only)
// ARB_ES3_compatibility (no entry points)
// ARB_clear_buffer_object
// ARB_compute_shader
// ARB_copy_image
// KHR_debug (includes ARB_debug_output commands promoted to KHR without suffixes)
// ARB_explicit_uniform_location (no entry points)
// ARB_framebuffer_no_attachments
// ARB_internalformat_query2
// ARB_invalidate_subdata
// ARB_multi_draw_indirect
// ARB_program_interface_query
// ARB_robust_buffer_access_behavior (no entry points)
// ARB_shader_storage_buffer_object
// ARB_stencil_texturing (no entry points)
// ARB_texture_buffer_range
// ARB_texture_query_levels (no entry points)
// ARB_texture_storage_multisample
// ARB_texture_view
// ARB_vertex_attrib_binding
#endif

#endif	// NWG_OGL_V4_H